package edu.unitec.matrox;

import java.util.*;
import java.io.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

parser code {:
  public boolean syntaxErrors;

  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
    lexer = lex;
  }
:};

/* Types */
terminal INTEGER, CHAR, BOOLEAN, DOUBLE, STRING;

/* Boolean types */
terminal TRUE, FALSE;

/* Flow control structures */
terminal IF, ELSE, ELSEIF, WHILE, FOR, SWITCH, CASE, DEFAULT, END;

/* Functions */
terminal MAIN, FUNCTION, RETURN, VOID;

/* I/O */
terminal WRITE, READ;

/* COMMA & SEMICOLON symbol */
terminal COMMA, SEMICOLON;

/* Arithmetic operators */
terminal ADD, MIN, MUL, DIV, UMIN, UPINC, UPDEC;

/* Grouping symbols */
terminal LPAR, RPAR, LBRACK, RBRACK;

/* Relationship operators */
terminal GREATEREQ, LESSEQ, GREATER, LESS, NEQ, EQU;

/* Logic operators */
terminal NOT, OR, AND;

/* Assignment operator */
terminal ASSIGN, ASSIGNADD, ASSIGNMIN, ASSIGNMUL, ASSIGNDIV;

/* Values */
terminal String IDENTIFIER;
terminal Integer INTNUMBER;
terminal Double DOUBLENUMBER;
terminal Character CHARCONTENT;
terminal String STRINGCONTENT;

/* Non terminals */
non terminal program, statements, statement, exp, literal_exp, numeric_exp, boolean_exp, logical_exp, while_statement, switch_statement, switch_case_statements, switch_case_statement, switch_case_exp_list, if_statement, else_if_statements, else_if_statement, variable_declaration, variable_declarators, variable_declarator, parameters, parameter, arguments, type, for_init, for_statement, function_declarations, function_declaration, function_call; 

/* Precedences */
precedence right ASSIGN, ASSIGNADD, ASSIGNMIN, ASSIGNMUL, ASSIGNDIV;
precedence left OR;
precedence left AND;
precedence left LESS, LESSEQ, GREATER, GREATEREQ, EQU, NEQ;
precedence left ADD, MIN;
precedence left MUL, DIV;
precedence right UMIN, NOT;
precedence right UPINC, UPDEC;
precedence nonassoc ELSE;

program ::= function_declarations
;

statements ::= statement statements
            | /* Lambda */
;


statement ::= if_statement
            | while_statement
            | for_statement
            | switch_statement
            | variable_declaration
            | variable_declarator
            | RETURN exp
            | READ exp
            | WRITE exp
            | exp:e
            | error:e
;

exp ::= numeric_exp:e
        | boolean_exp:e
        | logical_exp:e
        | literal_exp:e
        | function_call:e
        | IDENTIFIER:i
        | LPAR exp:e RPAR
;

literal_exp ::= INTNUMBER:i
                | DOUBLENUMBER:d
                | STRINGCONTENT:s
                | CHARCONTENT:c
;

numeric_exp ::= MIN exp:e
                %prec UMIN
                //| ADD ADD exp:e
                //%prec UPRINC
                //| MIN MIN exp:e
                //%prec UPRDEC
                | exp:e ADD ADD
                %prec UPINC
                | exp:e MIN MIN
                %prec UPDEC
                | exp:e1 ADD exp:e2
                | exp:e1 ADD ASSIGN exp:e2
                %prec ASSIGNADD
                | exp:e1 MIN exp:e2
                | exp:e1 MIN ASSIGN exp:e2
                %prec ASSIGNMIN
                | exp:e1 MUL exp:e2
                | exp:e1 MUL ASSIGN exp:e2
                %prec ASSIGNMUL
                | exp:e1 DIV exp:e2
                | exp:e1 DIV ASSIGN exp:e2
                %prec ASSIGNDIV
;

boolean_exp ::= exp:e1 GREATER exp:e2
            | exp:e1 LESS exp:e2
            | exp:e1 GREATEREQ exp:e2
            | exp:e1 LESSEQ exp:e2
            | exp:e1 EQU exp:e2
            | exp:e1 NEQ exp:e2
;

logical_exp ::= NOT exp:e
           | exp:e1 OR exp:e2
           | exp:e1 AND exp:e2
           | TRUE
           | FALSE
;

while_statement ::= WHILE LPAR exp:e RPAR statements END
;

switch_statement ::= SWITCH LPAR exp:e RPAR switch_case_statements END
;

switch_case_statements ::= switch_case_statement switch_case_statements
                        | switch_case_statement
;

switch_case_statement ::= CASE switch_case_exp_list statements END
                        | CASE DEFAULT statements END
;

switch_case_exp_list ::= exp:e COMMA switch_case_exp_list
                        | exp:e
;


if_statement ::= IF LPAR exp:e RPAR statements END
                | IF LPAR exp:e RPAR statements ELSE statements END
                | IF LPAR exp:e RPAR statements else_if_statements END
                | IF LPAR exp:e RPAR statements else_if_statements ELSE statements END
;

else_if_statements ::= else_if_statement else_if_statements
                    | else_if_statement
;

else_if_statement ::= ELSEIF LPAR exp RPAR statements
;

variable_declaration ::= type variable_declarators
                        | type IDENTIFIER
;

variable_declarators ::= variable_declarator COMMA variable_declarators
                        | variable_declarator
;

variable_declarator ::= IDENTIFIER ASSIGN exp:e
;

parameters ::= parameter COMMA parameters
        | parameter
;

parameter ::= type IDENTIFIER
;

arguments ::= exp COMMA arguments
            | exp
;

type ::= INTEGER
        | CHAR
        | BOOLEAN
        | DOUBLE
        | STRING
;

for_init ::= variable_declaration
            | variable_declarator
;

for_statement ::= FOR LPAR for_init SEMICOLON exp SEMICOLON exp RPAR statements END
                | FOR LPAR for_init SEMICOLON exp SEMICOLON variable_declarator RPAR statements END
;

function_declarations ::= function_declaration function_declarations
                        | function_declaration
;

function_declaration ::= FUNCTION type IDENTIFIER LBRACK parameters RBRACK statements END
           | FUNCTION type IDENTIFIER LBRACK RBRACK statements END
           | FUNCTION VOID IDENTIFIER LBRACK RBRACK statements END
           | FUNCTION VOID IDENTIFIER LBRACK parameters RBRACK statements END
           | FUNCTION INTEGER MAIN LBRACK RBRACK statements END
;

function_call ::= IDENTIFIER LBRACK arguments RBRACK
;
