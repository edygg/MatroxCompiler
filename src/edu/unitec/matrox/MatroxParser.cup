package edu.unitec.matrox;

import java.util.*;
import java.io.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

parser code {:
  public boolean syntaxErrors;

  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
    lexer = lex;
  }
:};

/* Types */
terminal INTEGER, CHAR, BOOLEAN, DOUBLE, STRING;

/* Boolean types */
terminal TRUE, FALSE;

/* Flow control structures */
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, BREAK, DEFAULT, END;

/* Functions */
terminal FUNCTION, RETURN, VOID;

/* I/O */
terminal WRITE, READ;

/* COMMA & COLON symbol */
terminal COMMA, COLON;

/* Arithmetic operators */
terminal ADD, MIN, MUL, DIV;

/* Grouping symbols */
terminal LPAR, RPAR, LBRACK, RBRACK;

/* Relationship operators */
terminal GREATEREQ, LESSEQ, GREATER, LESS, NEQ, EQU;

/* Logic operators */
terminal NOT, OR, AND;

/* Assignment operator */
terminal ASSIGN;

/* Values */
terminal String IDENTIFIER;
terminal Integer INTNUMBER;
terminal Double DOUBLENUMBER;
terminal Character CHARCONTENT;
terminal String STRINGCONTENT;

/* Non terminals */
non terminal exp, statement, while_Statement ,switch_Statement, if_Statement ,numeric_Exp, logical_Exp, compare_Exp, string_Exp, arg_List;

/* Precedences */
precedence left ADD, MIN;
precedence left MUL, DIV;

string_Exp ::= 
      exp:e1 ADD exp:e2             {: RESULT = stringExp.concat(e1,e2); :}
;

numeric_Exp ::=
      MIN exp:e                     {: RESULT = -e; :}
      | ADD ADD exp:e               {: RESULT = ++e; :}
      | MIN MIN exp:e               {: RESULT = --e; :}
      | exp:e ADD ADD               {: RESULT = e++; :}
      | exp:e MIN MIN               {: RESULT = e--; :}
      | exp:e1 ADD exp:e2           {: RESULT = e1 + e2; :}
      | exp:e1 ADD EQU exp:e2       {: RESULT = e1 += e2; :}
      | exp:e1 MIN exp:e2           {: RESULT = e1 - e2; :}
      | exp:e1 MIN EQU exp:e2       {: RESULT = e1 -= e2; :}
      | exp:e1 MUL exp:e2           {: RESULT = e1 * e2; :}
      | exp:e1 MUL EQU exp:e2       {: RESULT = e1 *= e2; :}
      | exp:e1 DIV exp:e2           {: RESULT = e1 / e2; :}
      | exp:e1 DIV EQU exp:e2       {: RESULT = e1 /= e2; :}
;
 

compare_Exp ::= 
      exp:e1 GREATER exp:e2         {: RESULT = e1 > e2; :}
      | exp:e1 LESS exp:e2          {: RESULT = e1 < e2; :}
      | exp:e1 GREATEREQ exp:e2     {: RESULT = e1 >= e2; :}
      | exp:e1 LESSEQ exp:e2        {: RESULT = e1 <= e2; :}
      | exp:e1 EQU exp:e2           {: RESULT = e1 = e2; :}
      | exp:e1 NEQ exp:e2           {: RESULT = e1 <> e2; :}
;

logical_Exp ::= 
      NOT exp:e                     {: RESULT = not e; :}
      | exp:e1 OR exp:e2            {: RESULT = e1 or e2; :}
      | exp:e1 AND exp:e2           {: RESULT = e1 and e2; :}
      | exp:e1 EQU exp:e2           {: RESULT = e1 = e2; :}
      | TRUE                        {: RESULT = true; :}
      | FALSE                       {: RESULT = false; :}      
;

arg_List ::= 
      exp 
      | COMMA exp 
; 

/*
exp ::= 
      numericExp 
      | compareExp 
      | logicalExp 
      | stringExp  
      | IDENTIFIER
      | LPAR exp RPAR  
      | exp LBRACK argList RBRACK 
      | exp LBRACK exp RBRACK  
      | exp COMMA exp  
;
*/

while_Statement ::= 
      WHILE LPAR exp RPAR statement
      END
;

switch_Statement ::= 
      SWITCH LPAR exp LPAR  
      CASE exp   
      |  DEFAULT   
      | statement
      END 
;

if_Sstatement ::= 
      IF LPAR exp RPAR statement 
      | ELSE IF LPAR statement RPAR
      | ELSE statement 
      END  
;