package edu.unitec.matrox;

import edu.unitec.ast.*;
import java.util.*;
import java.io.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

parser code {:
  public boolean syntaxErrors;

  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
    lexer = lex;
  }
:};

/* Types */
terminal INTEGER, CHAR, BOOLEAN, DOUBLE, STRING;

/* Boolean types */
terminal TRUE, FALSE;

/* Flow control structures */
terminal IF, ELSE, ELSEIF, WHILE, FOR, SWITCH, CASE, DEFAULT, END;

/* Functions */
terminal MAIN, FUNCTION, RETURN, VOID;

/* I/O */
terminal WRITE, READ;

/* COMMA & SEMICOLON symbol */
terminal COMMA, SEMICOLON;

/* Arithmetic operators */
terminal ADD, MIN, MUL, DIV, UMIN, UPINC, UPDEC;

/* Grouping symbols */
terminal LPAR, RPAR, LBRACK, RBRACK;

/* Relationship operators */
terminal GREATEREQ, LESSEQ, GREATER, LESS, NEQ, EQU;

/* Logic operators */
terminal NOT, OR, AND;

/* Assignment operator */
terminal ASSIGN, ASSIGNADD, ASSIGNMIN, ASSIGNMUL, ASSIGNDIV;

/* Values */
terminal String IDENTIFIER;
terminal Integer INTNUMBER;
terminal Double DOUBLENUMBER;
terminal Character CHARCONTENT;
terminal String STRINGCONTENT;

/* Non terminals */
non terminal Program program;
non terminal List<Statement> statements;
non terminal Statement statement;
non terminal Exp exp; 
non terminal LiteralExp literal_exp;
non terminal NumericExp numeric_exp;
non terminal BooleanExp boolean_exp;
non terminal LogicalExp logical_exp; 
non terminal While while_statement; 
non terminal SwitchStatement switch_statement; 
non terminal SwitchCaseStatements switch_case_statements; 
non terminal SwitchCaseStatement switch_case_statement; 
non terminal SwitchCaseExpList switch_case_exp_list; 
non terminal If if_statement; 
non terminal else_if_statements;  //---------
non terminal else_if_statement;   //---------
non terminal VariableDeclaration variable_declaration; 
non terminal List<VariableDeclarator> variable_declarators; 
non terminal VariableDeclarator variable_declarator; 
non terminal List<Parameter> parameters; 
non terminal Parameter parameter; 
non terminal List<Arguments> arguments; 
non terminal Type type; 
non terminal ForInit for_init; 
non terminal For for_statement; 
non terminal List<FunctionDeclaration> function_declarations; 
non terminal FunctionDeclaration function_declaration; 
non terminal FunctionCall function_call; 

/* Precedences */
precedence right ASSIGN, ASSIGNADD, ASSIGNMIN, ASSIGNMUL, ASSIGNDIV;
precedence left OR;
precedence left AND;
precedence left LESS, LESSEQ, GREATER, GREATEREQ, EQU, NEQ;
precedence left ADD, MIN;
precedence left MUL, DIV;
precedence right UMIN, NOT;
precedence right UPINC, UPDEC;
precedence nonassoc ELSE;

program ::= function_declarations:fds      
;

statements ::= statement:s statements:ss    
            | /* Lambda */                 
;


statement ::= if_statement
            | while_statement
            | for_statement
            | switch_statement
            | variable_declaration
            | variable_declarator
            | RETURN exp
            | READ exp
            | WRITE exp
            | exp:e
            | error:e
;

exp ::= numeric_exp:e                           {: RESULT = e; :}
        | boolean_exp:e                         {: RESULT = e; :}
        | logical_exp:e                         {: RESULT = e; :}    
        | literal_exp:e                         {: RESULT = e; :}
        | function_call:e
        | IDENTIFIER:i                          {: RESULT = new Identifier(i); :}
        | LPAR exp:e RPAR                       {: RESULT = new LParExpRPar(e); :}    
;

literal_exp ::= INTNUMBER:i                     {: RESULT = new IntegerLiteral(i); :}
                | DOUBLENUMBER:d                {: RESULT = new DoubleLiteral(d); :}
                | STRINGCONTENT:s               {: RESULT = new StringLiteral(s); :}
                | CHARCONTENT:c                 {: RESULT = new CharLiteral(c); :}
;

numeric_exp ::= MIN exp:e                       {: RESULT = new Umin(e); :}
                %prec UMIN
                //| ADD ADD exp:e               {: RESULT = new Uprinc(e); :}
                //%prec UPRINC
                //| MIN MIN exp:e               {: RESULT = new Uprdec(e); :}
                //%prec UPRDEC
                | exp:e ADD ADD                 {: RESULT = new Upinc(e); :}
                %prec UPINC                     
                | exp:e MIN MIN                 {: RESULT = new Updec(e); :}               
                %prec UPDEC                     
                | exp:e1 ADD exp:e2             {: RESULT = new Add(e1, e2); :}
                | exp:e1 ADD ASSIGN exp:e2      {: RESULT = new AddAssign(e1,e2); :}
                %prec ASSIGNADD
                | exp:e1 MIN exp:e2             {: RESULT = new Min(e1,e2); :}
                | exp:e1 MIN ASSIGN exp:e2      {: RESULT = new MinAssign(e1,e2); :}
                %prec ASSIGNMIN
                | exp:e1 MUL exp:e2             {: RESULT = new Mul(e1,e2); :}
                | exp:e1 MUL ASSIGN exp:e2      {: RESULT = new MulAssign(e1,e2); :}    
                %prec ASSIGNMUL
                | exp:e1 DIV exp:e2             {: RESULT = new Div(e1,e2); :}
                | exp:e1 DIV ASSIGN exp:e2      {: RESULT = new DivAssign(e1,e2); :}
                %prec ASSIGNDIV
;

boolean_exp ::= exp:e1 GREATER exp:e2           {: RESULT = new Greater(e1,e2); :}
            | exp:e1 LESS exp:e2                {: RESULT = new Less(e1,e2); :}
            | exp:e1 GREATEREQ exp:e2           {: RESULT = new GreaterEq(e1,e2); :}
            | exp:e1 LESSEQ exp:e2              {: RESULT = new LessEq(e1,e2); :}
            | exp:e1 EQU exp:e2                 {: RESULT = new Equ(e1,e2); :}
            | exp:e1 NEQ exp:e2                 {: RESULT = new Neq(e1,e2); :}
;

logical_exp ::= NOT exp:e                       {: RESULT = new Not(e); :}
           | exp:e1 OR exp:e2                   {: RESULT = new Or(e1,e2); :}
           | exp:e1 AND exp:e2                  {: RESULT = new And(e1,e2); :}
           | TRUE                               {: RESULT = new True(); :}
           | FALSE                              {: RESULT = new False(); :}
;

while_statement ::= WHILE LPAR exp:e RPAR statements END
;

switch_statement ::= SWITCH LPAR exp:e RPAR switch_case_statements END
;

switch_case_statements ::= switch_case_statement switch_case_statements
                        | switch_case_statement
;

switch_case_statement ::= CASE switch_case_exp_list statements END
                        | CASE DEFAULT statements END
;

switch_case_exp_list ::= exp:e COMMA switch_case_exp_list
                        | exp:e
;

if_statement ::= IF LPAR exp:e RPAR statements END
                | IF LPAR exp:e RPAR statements ELSE statements END
                | IF LPAR exp:e RPAR statements else_if_statements END
                | IF LPAR exp:e RPAR statements else_if_statements ELSE statements END
;

else_if_statements ::= else_if_statement else_if_statements
                    | else_if_statement
;

else_if_statement ::= ELSEIF LPAR exp RPAR statements
;

variable_declaration ::= type variable_declarators
                        | type IDENTIFIER
;

variable_declarators ::= variable_declarator COMMA variable_declarators
                        | variable_declarator
;

variable_declarator ::= IDENTIFIER ASSIGN exp:e
;

parameters ::= parameter:p COMMA parameters:ps        {: ps.add(p); RESULT = ps;  :}    
        | parameter:p                                 // {: RESULT = p; :}  
;

parameter ::= type:t IDENTIFIER:i                     {: RESULT = new Parameter(t, new Identifier(i)); :}
;

arguments ::= exp COMMA arguments                     
            | exp
;

type ::= INTEGER                                      {: RESULT = new IntegerType(); :}
        | CHAR                                        {: RESULT = new IntegerType(); :}  
        | BOOLEAN                                     {: RESULT = new BooleanType(); :}  
        | DOUBLE                                      {: RESULT = new DoubleType(); :}  
        | STRING                                      {: RESULT = new StringType(); :}  
;

for_init ::= variable_declaration 
            | variable_declarator  
;

for_statement ::= FOR LPAR for_init SEMICOLON exp SEMICOLON exp RPAR statements END
                | FOR LPAR for_init SEMICOLON exp SEMICOLON variable_declarator RPAR statements END
;

function_declarations ::= function_declaration function_declarations
                        | function_declaration
;

function_declaration ::= FUNCTION type IDENTIFIER LBRACK parameters RBRACK statements END
           | FUNCTION type IDENTIFIER LBRACK RBRACK statements END
           | FUNCTION VOID IDENTIFIER LBRACK RBRACK statements END
           | FUNCTION VOID IDENTIFIER LBRACK parameters RBRACK statements END
           | FUNCTION INTEGER MAIN LBRACK RBRACK statements END
;

function_call ::= IDENTIFIER:i LBRACK arguments:a RBRACK   
;
