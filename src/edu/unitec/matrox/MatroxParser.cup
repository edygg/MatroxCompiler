package edu.unitec.matrox;

import edu.unitec.ast.*;
import java.util.*;
import java.io.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

parser code {:
    public boolean syntaxErrors;

    Lexer lexer;

    public Parser(Lexer lex, ComplexSymbolFactory sf) {
      super(lex,sf);
      lexer = lex;
    }
    
    public void syntax_error(Symbol cur_token) {
        System.err.println("Syntax error at line: " + (cur_token.left + 1) + ", col: " + (cur_token.left + 1));
    }
    
:};

/* Types */
terminal INTEGER, CHAR, BOOLEAN, DOUBLE, STRING;

/* Boolean types */
terminal TRUE, FALSE;

/* Flow control structures */
terminal IF, ELSE, ELSEIF, WHILE, FOR, SWITCH, CASE, DEFAULT, END;

/* Functions */
terminal MAIN, FUNCTION, RETURN, VOID;

/* I/O */
terminal WRITE, READ;

/* COMMA & SEMICOLON symbol */
terminal COMMA, SEMICOLON;

/* Arithmetic operators */
terminal ADD, MIN, MUL, DIV, UMIN, UPINC, UPDEC;

/* Grouping symbols */
terminal LPAR, RPAR, LBRACK, RBRACK;

/* Relationship operators */
terminal GREATEREQ, LESSEQ, GREATER, LESS, NEQ, EQU;

/* Logic operators */
terminal NOT, OR, AND;

/* Assignment operator */
terminal ASSIGN, ASSIGNADD, ASSIGNMIN, ASSIGNMUL, ASSIGNDIV;

/* Values */
terminal String IDENTIFIER;
terminal Integer INTNUMBER;
terminal Double DOUBLENUMBER;
terminal Character CHARCONTENT;
terminal String STRINGCONTENT;

/* Non terminals */
non terminal Program program;
non terminal Statements statements;
non terminal Statement statement;
non terminal Exp exp; 
non terminal LiteralExp literal_exp;
non terminal NumericExp numeric_exp;
non terminal BooleanExp boolean_exp;
non terminal LogicalExp logical_exp; 
non terminal While while_statement; 
non terminal SwitchStatement switch_statement; 
non terminal SwitchCaseStatements switch_case_statements; 
non terminal SwitchCaseStatement switch_case_statement; 
non terminal SwitchCaseExpList switch_case_exp_list; 
non terminal If if_statement; 
non terminal ElseIfStatements else_if_statements;
non terminal ElseIfStatement else_if_statement;
non terminal VariableDeclaration variable_declaration; 
non terminal VariableDeclarators variable_declarators; 
non terminal VariableDeclarator variable_declarator; 
non terminal Parameters parameters; 
non terminal Parameter parameter; 
non terminal Arguments arguments; 
non terminal Type type; 
non terminal ForInit for_init; 
non terminal For for_statement; 
non terminal FunctionDeclarations function_declarations; 
non terminal FunctionDeclaration function_declaration; 
non terminal FunctionCall function_call; 

/* Precedences */
precedence right ASSIGN, ASSIGNADD, ASSIGNMIN, ASSIGNMUL, ASSIGNDIV;
precedence left OR;
precedence left AND;
precedence left LESS, LESSEQ, GREATER, GREATEREQ, EQU, NEQ;
precedence left ADD, MIN;
precedence left MUL, DIV;
precedence right UMIN, NOT;
precedence right UPINC, UPDEC;
precedence nonassoc ELSE;

program ::= function_declarations:fdons           {: RESULT = new Program(fdons); :}      
;

statements ::= statement:stmt statements:stmts    {: stmts.addElement(stmt); RESULT = stmts; :}    
            | /* Lambda */                        {: RESULT = new Statements(); :}
;


statement ::= if_statement:istmt                {: RESULT = istmt; :}
            | while_statement:wstmt             {: RESULT = wstmt; :}           
            | for_statement:fstmt               {: RESULT = fstmt; :}                     
            | switch_statement:sstmt            {: RESULT = sstmt; :}
            | variable_declaration:vdon         {: RESULT = vdon; :}
            | variable_declarator:vdor          {: RESULT = vdor; :}
            | RETURN exp:e                      {: RESULT = new Return(e);  :}
            | READ exp:e                        {: RESULT = new Read(e); :}
            | WRITE exp:e                       {: RESULT = new Write(e); :}
            | exp:e                             {: RESULT = e ; :}
;

exp ::= numeric_exp:e                           {: RESULT = e; :}
        | boolean_exp:e                         {: RESULT = e; :}
        | logical_exp:e                         {: RESULT = e; :}    
        | literal_exp:e                         {: RESULT = e; :}
        | function_call:fc                      {: RESULT = fc; :}
        | IDENTIFIER:i                          {: RESULT = new Identifier(i); :}
        | LPAR exp:e RPAR                       {: RESULT = new LParExpRPar(e); :}
        | error exp                             {: System.out.println("Error en expresi√≥n"); :}
;

literal_exp ::= INTNUMBER:i                     {: RESULT = new IntegerLiteral(i); :}
                | DOUBLENUMBER:d                {: RESULT = new DoubleLiteral(d); :}
                | STRINGCONTENT:s               {: RESULT = new StringLiteral(s); :}
                | CHARCONTENT:c                 {: RESULT = new CharLiteral(c); :}
;

numeric_exp ::= MIN exp:e                       {: RESULT = new Umin(e); :}
                %prec UMIN
                //| ADD ADD exp:e               {: RESULT = new Uprinc(e); :}
                //%prec UPRINC
                //| MIN MIN exp:e               {: RESULT = new Uprdec(e); :}
                //%prec UPRDEC
                | exp:e ADD ADD                 {: RESULT = new Upinc(e); :}
                %prec UPINC                     
                | exp:e MIN MIN                 {: RESULT = new Updec(e); :}               
                %prec UPDEC                     
                | exp:e1 ADD exp:e2             {: RESULT = new Add(e1, e2); :}
                | exp:e1 ADD ASSIGN exp:e2      {: RESULT = new AddAssign(e1,e2); :}
                %prec ASSIGNADD
                | exp:e1 MIN exp:e2             {: RESULT = new Min(e1,e2); :}
                | exp:e1 MIN ASSIGN exp:e2      {: RESULT = new MinAssign(e1,e2); :}
                %prec ASSIGNMIN
                | exp:e1 MUL exp:e2             {: RESULT = new Mul(e1,e2); :}
                | exp:e1 MUL ASSIGN exp:e2      {: RESULT = new MulAssign(e1,e2); :}    
                %prec ASSIGNMUL
                | exp:e1 DIV exp:e2             {: RESULT = new Div(e1,e2); :}
                | exp:e1 DIV ASSIGN exp:e2      {: RESULT = new DivAssign(e1,e2); :}
                %prec ASSIGNDIV
;

boolean_exp ::= exp:e1 GREATER exp:e2           {: RESULT = new Greater(e1,e2); :}
            | exp:e1 LESS exp:e2                {: RESULT = new Less(e1,e2); :}
            | exp:e1 GREATEREQ exp:e2           {: RESULT = new GreaterEq(e1,e2); :}
            | exp:e1 LESSEQ exp:e2              {: RESULT = new LessEq(e1,e2); :}
            | exp:e1 EQU exp:e2                 {: RESULT = new Equ(e1,e2); :}
            | exp:e1 NEQ exp:e2                 {: RESULT = new Neq(e1,e2); :}
;

logical_exp ::= NOT exp:e                       {: RESULT = new Not(e); :}
           | exp:e1 OR exp:e2                   {: RESULT = new Or(e1,e2); :}
           | exp:e1 AND exp:e2                  {: RESULT = new And(e1,e2); :}
           | TRUE                               {: RESULT = new True(); :}
           | FALSE                              {: RESULT = new False(); :}
;

while_statement ::= WHILE LPAR exp:e RPAR statements:stmts END                              {: RESULT = new While(e, stmts); :}
;

switch_statement ::= SWITCH LPAR exp:e RPAR switch_case_statements:scstmts END              {: RESULT = new SwitchStatement(e, scstmts); :}
;

switch_case_statements ::= switch_case_statement:scstmt switch_case_statements:scstmts      {: scstmts.addElement(scstmt); RESULT = scstmts; :}
                        | switch_case_statement:scstmt                                      {: RESULT = new SwitchCaseStatements(); RESULT.addElement(scstmt);  :}
;

switch_case_statement ::= CASE switch_case_exp_list:scexpl statements:stmts END             {: RESULT = new SwitchCaseStatement(scexpl, stmts); :}
                        | CASE DEFAULT statements:stmts END                                 {: RESULT = new SwitchCaseStatement(stmts); :}
;

switch_case_exp_list ::= exp:e COMMA switch_case_exp_list:scexpl                            {: scexpl.addElement(e); RESULT = scexpl;  :}
                        | exp:e                                                             {: RESULT = new SwitchCaseExpList(); RESULT.addElement(e); :}
;

if_statement ::= IF LPAR exp:e RPAR statements:stmts END                                    {: RESULT = new If(e, stmts); :}                                         
                | IF LPAR exp:e RPAR statements:stmts1 ELSE statements:stmts2 END           {: RESULT = new If(e, stmts1, stmts2); :}
                | IF LPAR exp:e RPAR statements:stmts1 else_if_statements:eistmts END       {: RESULT = new If(e, stmts1, eistmts); :}
                | IF LPAR exp:e RPAR statements:stmts1 else_if_statements:eistmts ELSE statements:stmts2 END      {: RESULT = new If(e, stmts1, eistmts, stmts2); :}
;

else_if_statements ::= else_if_statement:eistmt else_if_statements:eistmts                  {: eistmts.addElement(eistmt); RESULT = eistmts;  :}
                    | else_if_statement:eistmt                                              {: RESULT = new ElseIfStatements(); RESULT.addElement(eistmts); :}
;

else_if_statement ::= ELSEIF LPAR exp:e RPAR statements:stmts                               {: RESULT = new ElseIfStatement(e, stmts); :}
;

variable_declaration ::= type:t variable_declarators:vdors                                  {: RESULT = new VariableDeclaration(t, vdors); :}
                        | type:t IDENTIFIER:i                                               {: RESULT = new VariableDeclaration(t, new Identifier(i)); :}
;

variable_declarators ::= variable_declarator:vdor COMMA variable_declarators:vdors          {: vdors.addElement(vdor); RESULT = vdors; :}
                        | variable_declarator:vdor                                          {: RESULT = new VariableDeclarators(); RESULT.addElement(vdor); :}               
;

variable_declarator ::= IDENTIFIER:i ASSIGN exp:e                                           {: RESULT = new VariableDeclarator(new Identifier(i), e); :}
;

parameters ::= parameter:p COMMA parameters:ps                                              {: ps.addElement(p); RESULT = ps; :}    
        | parameter:p                                                                       {: RESULT = new Parameters(); RESULT.addElement(p); :}  
;

parameter ::= type:t IDENTIFIER:i                                                           {: RESULT = new Parameter(t, new Identifier(i)); :}
;

arguments ::= exp:e COMMA arguments:args                                                    {: args.addElement(e); RESULT = args; :}
            | exp:e                                                                         {: RESULT = new Arguments(); RESULT.addElement(e); :}
;

type ::= INTEGER                                                                            {: RESULT = new IntegerType(); :}
        | CHAR                                                                              {: RESULT = new CharType(); :}  
        | BOOLEAN                                                                           {: RESULT = new BooleanType(); :}  
        | DOUBLE                                                                            {: RESULT = new DoubleType(); :}  
        | STRING                                                                            {: RESULT = new StringType(); :}  
;

for_init ::= variable_declaration:vdon                                                      {: RESULT = new ForInit(vdon); :}
            | variable_declarator:vdor                                                      {: RESULT = new ForInit(vdor); :}
;

for_statement ::= FOR LPAR for_init:fi SEMICOLON exp:e1 SEMICOLON exp:e2 RPAR statements:stmts END                      {: RESULT = new For(fi, e1, e2, stmts);  :}
                | FOR LPAR for_init:fi SEMICOLON exp:e1 SEMICOLON variable_declarator:vdor RPAR statements:stmts END    {: RESULT = new For(fi, e1, vdor, stmts); :}
;

function_declarations ::= function_declaration:fdon function_declarations:fdons                                         {: fdons.addElement(fdon); RESULT = fdons; :}
                        | function_declaration:fdon                                                                     {: RESULT = new FunctionDeclarations(); RESULT.addElement(fdon); :}
;

function_declaration ::= FUNCTION type:t IDENTIFIER:i LBRACK parameters:ps RBRACK statements:stmts END                  {: RESULT = new FunctionDeclaration(t, new Identifier(i), ps, stmts); :}
           | FUNCTION type:t IDENTIFIER:i LBRACK RBRACK statements:stmts END                                            {: RESULT = new FunctionDeclaration(t, new Identifier(i), null, stmts); :}
           | FUNCTION VOID IDENTIFIER:i LBRACK RBRACK statements:stmts END                                              {: RESULT = new FunctionDeclaration(new Identifier(i), null, stmts); :}
           | FUNCTION VOID IDENTIFIER:i LBRACK parameters:ps RBRACK statements:stmts END                                {: RESULT = new FunctionDeclaration(new Identifier(i), ps, stmts); :}
           | FUNCTION INTEGER MAIN LBRACK RBRACK statements:stmts END                                                   {: RESULT = new FunctionDeclaration(new IntegerType(), new Identifier("main"), null, stmts); :}
;

function_call ::= IDENTIFIER:i LBRACK arguments:args RBRACK                                                             {: RESULT = new FunctionCall(new Identifier(i), args); :}                                                                {:  :}
;
