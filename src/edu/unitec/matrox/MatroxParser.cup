package edu.unitec.matrox;

import java.util.*;
import java.io.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

parser code {:
  public boolean syntaxErrors;

  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
    lexer = lex;
  }
:};

/* Types */
terminal INTEGER, CHAR, BOOLEAN, DOUBLE, STRING;

/* Boolean types */
terminal TRUE, FALSE;

/* Flow control structures */
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, BREAK, DEFAULT, END;

/* Functions */
terminal FUNCTION, RETURN, VOID;

/* I/O */
terminal WRITE, READ;

/* COMMA & COLON symbol */
terminal COMMA, COLON;

/* Arithmetic operators */
terminal ADD, MIN, MUL, DIV, UMIN, UPINC, UPDEC, UPRINC, UPRDEC;

/* Grouping symbols */
terminal LPAR, RPAR, LBRACK, RBRACK;

/* Relationship operators */
terminal GREATEREQ, LESSEQ, GREATER, LESS, NEQ, EQU;

/* Logic operators */
terminal NOT, OR, AND;

/* Assignment operator */
terminal ASSIGN, ASSIGNADD, ASSIGNMIN, ASSIGNMUL, ASSIGNDIV;

/* Values */
terminal String IDENTIFIER;
terminal Integer INTNUMBER;
terminal Double DOUBLENUMBER;
terminal Character CHARCONTENT;
terminal String STRINGCONTENT;

/* Non terminals */
non terminal literal_exp, numeric_exp, string_exp, logical_exp, statements, exp, arg_list, statement ,if_statement, while_statement, switch_statement, result;
non terminal Boolean boolean_exp, compare_exp;

/* Precedences */
precedence right ASSIGN, ASSIGNADD, ASSIGNMIN, ASSIGNMUL, ASSIGNDIV;
precedence left OR;
precedence left AND;
precedence left LESS, LESSEQ, GREATER, GREATEREQ, EQU, NEQ;
precedence left ADD, MIN;
precedence left MUL, DIV;
precedence right UPRINC, UPRDEC, UMIN, NOT;
precedence right UPINC, UPDEC;

result ::= statements:s                        {: System.out.println(s); :}   
;                          

statements ::= statements:s exp:e              {: //System.out.print(e); :}    
                | exp:e                        {: //System.out.print(e); :} 
;

exp ::= numeric_exp 
        | boolean_exp 
        | logical_exp 
       // | string_exp
        | literal_exp
        | IDENTIFIER
        | LPAR exp RPAR
;

literal_exp ::= INTNUMBER:i                   {: RESULT = (int)i; :}
                | DOUBLENUMBER:d              {: RESULT = (double)d; :}
                | STRINGCONTENT:s             {: RESULT = (String)s; :}
                | CHARCONTENT:c               {: RESULT = (Character)c; :}
;

numeric_exp ::= MIN exp:e                     {: RESULT = - (Integer)e; :}
                %prec UMIN
                //| ADD ADD exp:e             {: RESULT = ++(int)e; :}
                //%prec UPRINC
                //| MIN MIN exp:e             {: RESULT = --(int)e; :}
                //%prec UPRDEC
                | exp:e ADD ADD               {: e = (Integer)e + 1; RESULT = e; :}
                %prec UPINC
                | exp:e MIN MIN               {: e = (Integer)e - 1; RESULT = e; :}
                %prec UPDEC
                | exp:e1 ADD exp:e2           {: if(e1 instanceof Integer) { RESULT = (Integer)e1 + (Integer)e2; } else { RESULT = (double)e1 + (double)e2; }   :}
                | exp:e1 ADD ASSIGN exp:e2    {: e1 = (Integer)e1 + (Integer)e2; RESULT = e1; :}
                %prec ASSIGNADD
                | exp:e1 MIN exp:e2           {: if(e1 instanceof Integer) { RESULT = (int)e1 - (int)e2; } else { RESULT = (double)e1 - (double)e2; }   :}
                | exp:e1 MIN ASSIGN exp:e2    {: e1 = (Integer)e1 - (Integer)e2; RESULT = e1; :}
                %prec ASSIGNMIN
                | exp:e1 MUL exp:e2           {: if(e1 instanceof Integer) { RESULT = (Integer)e1 * (Integer)e2; } else { RESULT = (double)e1 * (double)e2; }   :}
                | exp:e1 MUL ASSIGN exp:e2    {: e1 = (Integer)e1 * (Integer)e2; RESULT = e1; :}
                %prec ASSIGNMUL
                | exp:e1 DIV exp:e2           {: if(e1 instanceof Integer) { RESULT = (Integer)e1 / (Integer)e2; } else { RESULT = (double)e1 / (double)e2; }   :}
                | exp:e1 DIV ASSIGN exp:e2    {: e1 = (Integer)e1 / (Integer)e2; RESULT = e1; :}
                %prec ASSIGNDIV
;


string_exp ::= exp:e1 ADD exp:e2
              | exp:e1 ADD ASSIGN exp:e2
              %prec ASSIGNADD
;

boolean_exp ::= exp:e1 GREATER exp:e2         {: if((int)e1 > (int)e2) RESULT = true; else RESULT = false; :}
            | exp:e1 LESS exp:e2              {: if((int)e1 < (int)e2) RESULT = true; else RESULT = false; :}
            | exp:e1 GREATEREQ exp:e2         {: if((int)e1 >= (int)e2) RESULT = true; else RESULT = false; :}
            | exp:e1 LESSEQ exp:e2            {: if((int)e1 <= (int)e2) RESULT = true; else RESULT = false; :}
            | exp:e1 EQU exp:e2               {: if (e1 instanceof Integer) { if((int)e1 == (int)e2) { RESULT = true; } else { RESULT = false; } } else if (e1 instanceof Boolean) { if((boolean)e1 == (boolean)e2) { RESULT = true; } else { RESULT = false; } } else if (e1 instanceof Double) { if((double)e1 == (double)e2) { RESULT = true; } else { RESULT = false; } } else { if(e1.toString() == e2.toString()) { RESULT = true; } else { RESULT = false; } } :}
            | exp:e1 NEQ exp:e2               {: if (e1 instanceof Integer) { if((int)e1 != (int)e2) { RESULT = true; } else { RESULT = false; } } else if (e1 instanceof Boolean) { if((boolean)e1 != (boolean)e2) { RESULT = true; } else { RESULT = false; } } else if (e1 instanceof Double) { if((double)e1 != (double)e2) { RESULT = true; } else { RESULT = false; } } else { if(e1.toString() != e2.toString()) { RESULT = true; } else { RESULT = false; } } :}
;

logical_exp ::= NOT exp:e                     {: RESULT = !(boolean)e; :}
           | exp:e1 OR exp:e2                 {: RESULT = (boolean)e1 || (boolean)e2; :}
           | exp:e1 AND exp:e2                {: RESULT = (boolean)e1 && (boolean)e2; :}
           | TRUE                             {: RESULT = true; :}
           | FALSE                            {: RESULT = false; :}      
;

while_statement ::= WHILE LPAR exp RPAR statement END
;

switch_statement ::= 
      SWITCH LPAR exp LPAR  
      CASE exp   
      |  DEFAULT   
      | statement
      END 
;

if_statement ::= 
      IF LPAR exp RPAR statement 
      | ELSE IF LPAR statement RPAR
      | ELSE statement 
      END  
;