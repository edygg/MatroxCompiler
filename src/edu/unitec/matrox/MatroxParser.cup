package edu.unitec.matrox;

import java.util.*;
import java.io.*;
import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

parser code {:
  public boolean syntaxErrors;

  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
    lexer = lex;
  }
:};

/* Types */
terminal INTEGER, CHAR, BOOLEAN, DOUBLE, STRING;

/* Boolean types */
terminal TRUE, FALSE;

/* Flow control structures */
terminal IF, ELSE, ELSEIF, WHILE, FOR, SWITCH, CASE, BREAK, DEFAULT, END;

/* Functions */
terminal FUNCTION, RETURN, VOID;

/* I/O */
terminal WRITE, READ;

/* COMMA & COLON symbol */
terminal COMMA, COLON;

/* Arithmetic operators */
terminal ADD, MIN, MUL, DIV, UMIN, UPINC, UPDEC, UPRINC, UPRDEC;

/* Grouping symbols */
terminal LPAR, RPAR, LBRACK, RBRACK;

/* Relationship operators */
terminal GREATEREQ, LESSEQ, GREATER, LESS, NEQ, EQU;

/* Logic operators */
terminal NOT, OR, AND;

/* Assignment operator */
terminal ASSIGN, ASSIGNADD, ASSIGNMIN, ASSIGNMUL, ASSIGNDIV;

/* Values */
terminal String IDENTIFIER;
terminal Integer INTNUMBER;
terminal Double DOUBLENUMBER;
terminal Character CHARCONTENT;
terminal String STRINGCONTENT;

/* Non terminals */
non terminal parameters, parameter ,function_declaration, for_statement, variable_declaration, variable_declarators, variable_declarator, type, switch_case_statements, switch_case_statement, switch_case_exp_list, literal_exp, numeric_exp, string_exp, logical_exp, statements, exp, arg_list, statement ,if_statement, while_statement, switch_statement, result, else_if_statement, else_if_statements;
non terminal Boolean boolean_exp, compare_exp;

/* Precedences */
precedence right ASSIGN, ASSIGNADD, ASSIGNMIN, ASSIGNMUL, ASSIGNDIV;
precedence left OR;
precedence left AND;
precedence left LESS, LESSEQ, GREATER, GREATEREQ, EQU, NEQ;
precedence left ADD, MIN;
precedence left MUL, DIV;
precedence right UPRINC, UPRDEC, UMIN, NOT;
precedence right UPINC, UPDEC;
precedence nonassoc ELSE;

result ::= statements:s                        {: :}   
            | function_declaration              {: :}
;                          

statements ::= statement statements          {: :}
                | statement
;


statement ::= if_statement
            | while_statement
            | for_statement
            | switch_statement
            | variable_declaration
            | variable_declarator
            | RETURN exp
            | exp:e                             {: RESULT = e; System.out.println(e); :}
            | error:e                           {: parser.report_error("Syntax error, skip rest",e); :}    
;

exp ::= numeric_exp:e                           {: RESULT = e; :}
        | boolean_exp:e                         {: RESULT = e; :}
        | logical_exp:e                         {: RESULT = e; :}
        | literal_exp:e                         {: RESULT = e; :}
        | IDENTIFIER:i                          {: RESULT = i; :}
        | LPAR exp:e RPAR                       {: RESULT = e; :}
;

literal_exp ::= INTNUMBER:i                   {: RESULT = (int)i; :}
                | DOUBLENUMBER:d              {: RESULT = (double)d; :}
                | STRINGCONTENT:s             {: RESULT = (String)s; :}
                | CHARCONTENT:c               {: RESULT = (Character)c; :}
;

numeric_exp ::= MIN exp:e                     {: if (e instanceof Integer) RESULT = - (Integer)e; else RESULT = -((Double) e); :}
                %prec UMIN
                //| ADD ADD exp:e             {: RESULT = ++(int)e; :}
                //%prec UPRINC
                //| MIN MIN exp:e             {: RESULT = --(int)e; :}
                //%prec UPRDEC
                | exp:e ADD ADD               {: if (e instanceof Integer) RESULT = ((Integer)e) + 1; else RESULT = ((Double)e) + 1; RESULT = e; :}
                %prec UPINC
                | exp:e MIN MIN               {: if (e instanceof Integer) RESULT = ((Integer)e) - 1; else RESULT = ((Double)e) - 1; RESULT = e; :}
                %prec UPDEC
                | exp:e1 ADD exp:e2           {: if(e1 instanceof Integer && e2 instanceof Integer) { RESULT = (Integer)e1 + (Integer)e2; } else if(e1 instanceof String || e2 instanceof String) { RESULT = e1.toString() + e2.toString(); } else { RESULT = Double.parseDouble(e1.toString()) + Double.parseDouble(e2.toString()); }   :}
                | exp:e1 ADD ASSIGN exp:e2    {: if(e1 instanceof Integer && e2 instanceof Integer) { e1 = (int)e1 + (int)e2; RESULT = e1; } else if(e1 instanceof String || e2 instanceof String) { RESULT = e1.toString() + e2.toString(); } else { e1 = Double.parseDouble(e1.toString()) + Double.parseDouble(e2.toString()); RESULT = e1; } :}
                %prec ASSIGNADD
                | exp:e1 MIN exp:e2           {: if(e1 instanceof Integer && e2 instanceof Integer) { RESULT = (int)e1 - (int)e2; } else { RESULT = Double.parseDouble(e1.toString()) - Double.parseDouble(e2.toString()); }   :}
                | exp:e1 MIN ASSIGN exp:e2    {: if(e1 instanceof Integer && e2 instanceof Integer) { e1 = (int)e1 - (int)e2; RESULT = e1; } else { e1 = Double.parseDouble(e1.toString()) - Double.parseDouble(e2.toString()); RESULT = e1; } :}
                %prec ASSIGNMIN
                | exp:e1 MUL exp:e2           {: if(e1 instanceof Integer && e2 instanceof Integer) { RESULT = (Integer)e1 * (Integer)e2; } else { RESULT = Double.parseDouble(e1.toString()) * Double.parseDouble(e2.toString()); }   :}
                | exp:e1 MUL ASSIGN exp:e2    {: if(e1 instanceof Integer && e2 instanceof Integer) { e1 = (int)e1 * (int)e2; RESULT = e1; } else { e1 = Double.parseDouble(e1.toString()) * Double.parseDouble(e2.toString()); RESULT = e1; } :}
                %prec ASSIGNMUL
                | exp:e1 DIV exp:e2           {: if(e1 instanceof Integer && e2 instanceof Integer) { RESULT = (Integer)e1 / (Integer)e2; } else { RESULT = Double.parseDouble(e1.toString()) / Double.parseDouble(e2.toString()); }   :}
                | exp:e1 DIV ASSIGN exp:e2    {: if(e1 instanceof Integer && e2 instanceof Integer) { e1 = (int)e1 / (int)e2; RESULT = e1; } else { e1 = Double.parseDouble(e1.toString()) / Double.parseDouble(e2.toString()); RESULT = e1; } :}
                %prec ASSIGNDIV
;

boolean_exp ::= exp:e1 GREATER exp:e2         {: if((int)e1 > (int)e2) RESULT = true; else RESULT = false; :}
            | exp:e1 LESS exp:e2              {: if((int)e1 < (int)e2) RESULT = true; else RESULT = false; :}
            | exp:e1 GREATEREQ exp:e2         {: if((int)e1 >= (int)e2) RESULT = true; else RESULT = false; :}
            | exp:e1 LESSEQ exp:e2            {: if((int)e1 <= (int)e2) RESULT = true; else RESULT = false; :}
            | exp:e1 EQU exp:e2               {: if (e1 instanceof Integer) { if((int)e1 == (int)e2) { RESULT = true; } else { RESULT = false; } } else if (e1 instanceof Boolean) { if((boolean)e1 == (boolean)e2) { RESULT = true; } else { RESULT = false; } } else if (e1 instanceof Double) { if((double)e1 == (double)e2) { RESULT = true; } else { RESULT = false; } } else { if(e1.toString().equals( e2.toString())) { RESULT = true; } else { RESULT = false; } } :}
            | exp:e1 NEQ exp:e2               {: if (e1 instanceof Integer) { if((int)e1 != (int)e2) { RESULT = true; } else { RESULT = false; } } else if (e1 instanceof Boolean) { if((boolean)e1 != (boolean)e2) { RESULT = true; } else { RESULT = false; } } else if (e1 instanceof Double) { if((double)e1 != (double)e2) { RESULT = true; } else { RESULT = false; } } else { if(!e1.toString().equals( e2.toString())) { RESULT = true; } else { RESULT = false; } } :}
;

logical_exp ::= NOT exp:e                     {: RESULT = !(boolean)e; :}
           | exp:e1 OR exp:e2                 {: RESULT = (boolean)e1 || (boolean)e2; :}
           | exp:e1 AND exp:e2                {: RESULT = (boolean)e1 && (boolean)e2; :}
           | TRUE                             {: RESULT = true; :}
           | FALSE                            {: RESULT = false; :}      
;

while_statement ::= WHILE LPAR exp:e RPAR statements END                                  {: System.out.println("while exp: " + e); :}
;

switch_statement ::= SWITCH LPAR exp:e RPAR switch_case_statements END                    {: System.out.println("switch exp: " + e); :}
;

switch_case_statements ::= switch_case_statement switch_case_statements
                        | switch_case_statement
;

switch_case_statement ::= CASE switch_case_exp_list statements END
                        | CASE DEFAULT statements END
;

switch_case_exp_list ::= exp:e COMMA switch_case_exp_list                               {: System.out.println("switch case exp: " + e); :}
                        | exp:e                                                         {: System.out.println("switch case exp: " + e); :}
;


if_statement ::= IF LPAR exp:e RPAR statements END                                      {: System.out.println("if exp: " + e); :}
                | IF LPAR exp:e RPAR statements ELSE statements END                     {: System.out.println("if else exp: " + e); :}
                | IF LPAR exp:e RPAR statements else_if_statements END                  {: System.out.println("if elseif sin else exp: " + e); :}
                | IF LPAR exp:e RPAR statements else_if_statements ELSE statements END  {: System.out.println("if elseif con else exp: " + e); :}
;

else_if_statements ::= else_if_statement else_if_statements
                    | else_if_statement
;

else_if_statement ::= ELSEIF LPAR exp RPAR statements
;

variable_declaration ::= type variable_declarators
                        | type IDENTIFIER
;

variable_declarators ::= variable_declarator COMMA variable_declarators
                        | variable_declarator
;

variable_declarator ::= IDENTIFIER ASSIGN exp:e                                         {: System.out.println("Declaracion exp: " + e); :}
;

parameters ::= parameter COMMA parameters
        | parameter
;

parameter ::= type IDENTIFIER
;

type ::= INTEGER
        | CHAR
        | BOOLEAN
        | DOUBLE
        | STRING
;

for_statement ::= FOR LPAR type variable_declarator COMMA exp COMMA exp RPAR statements END     {: :}
            | FOR LPAR variable_declarator COMMA exp COMMA exp RPAR statements END              {: :}
;

function_declaration ::= FUNCTION type IDENTIFIER LBRACK parameters RBRACK statements END         
           | FUNCTION type IDENTIFIER LBRACK RBRACK statements END
           | FUNCTION VOID IDENTIFIER LBRACK parameters RBRACK statements END
           | FUNCTION VOID IDENTIFIER LBRACK RBRACK statements END
;
